# -*- generated by 1.1.0b15 -*-
import da
PatternExpr_538 = da.pat.TuplePattern([da.pat.ConstantPattern('Done')])
PatternExpr_543 = da.pat.BoundPattern('_BoundPattern545_')
PatternExpr_910 = da.pat.TuplePattern([da.pat.ConstantPattern('Proposal'), da.pat.FreePattern('proposal_msg')])
PatternExpr_917 = da.pat.FreePattern('p')
PatternExpr_1171 = da.pat.TuplePattern([da.pat.ConstantPattern('Vote'), da.pat.FreePattern('vote_msg')])
PatternExpr_1178 = da.pat.FreePattern('p')
PatternExpr_1261 = da.pat.TuplePattern([da.pat.ConstantPattern('Timeout'), da.pat.FreePattern('timeout_msg')])
PatternExpr_1268 = da.pat.FreePattern('p')
PatternExpr_1370 = da.pat.TuplePattern([da.pat.ConstantPattern('Request'), da.pat.FreePattern('signed_req')])
PatternExpr_1377 = da.pat.FreePattern('client')
PatternExpr_546 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern552_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Done')])])
_config_object = {}
import random
import threading
import time
from block_tree import BlockTree
from cryptography import Cryptography
from leader_election import LeaderElection
from ledger import Ledger
from logger_util import LOGGER
from mem_pool import MemPool
from object_types import FailType, MsgType, ProposalMsg
from pacemaker import Pacemaker
from safety import Safety

class Validator(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ValidatorReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ValidatorReceivedEvent_0', PatternExpr_538, sources=[PatternExpr_543], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ValidatorReceivedEvent_1', PatternExpr_910, sources=[PatternExpr_917], destinations=None, timestamps=None, record_history=None, handlers=[self._Validator_handler_909]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ValidatorReceivedEvent_2', PatternExpr_1171, sources=[PatternExpr_1178], destinations=None, timestamps=None, record_history=None, handlers=[self._Validator_handler_1170]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ValidatorReceivedEvent_3', PatternExpr_1261, sources=[PatternExpr_1268], destinations=None, timestamps=None, record_history=None, handlers=[self._Validator_handler_1260]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ValidatorReceivedEvent_4', PatternExpr_1370, sources=[PatternExpr_1377], destinations=None, timestamps=None, record_history=None, handlers=[self._Validator_handler_1369])])

    def setup(self, config, config_id, validator_id, replicas, clients, private_key, public_keys_validators, public_keys_clients, **rest_1789):
        super().setup(config=config, config_id=config_id, validator_id=validator_id, replicas=replicas, clients=clients, private_key=private_key, public_keys_validators=public_keys_validators, public_keys_clients=public_keys_clients, **rest_1789)
        self._state.config = config
        self._state.config_id = config_id
        self._state.validator_id = validator_id
        self._state.replicas = replicas
        self._state.clients = clients
        self._state.private_key = private_key
        self._state.public_keys_validators = public_keys_validators
        self._state.public_keys_clients = public_keys_clients
        LOGGER.replicas = self._state.replicas
        LOGGER.process_id = ('validator_' + str(self._state.validator_id))
        LOGGER.clients = self._state.clients
        LOGGER.filename = (((('../logs/config' + str(self._state.config_id)) + '/') + LOGGER.process_id) + '.log')
        LOGGER.log_action('Initial configuration', self._state.config)
        self._state.validator_id = self._state.validator_id
        self._state.network_playground = self._state.config['network_playground']
        self._state.id_block = dict()
        self._state.request_cache = dict()
        self._state.recently_committed_block_ids = list()
        self._state.should_start_new_round = True
        self._state.ledger = Ledger(self._state.config_id, self._state.validator_id, self._state.id_block, self._state.recently_committed_block_ids, self._state.request_cache)
        self._state.blocktree = BlockTree(self._state.validator_id, self._state.replicas, self._state.ledger, self._state.config['nfaulty'], self._state.id_block)
        self._state.safety = Safety(self._state.validator_id, self._state.replicas, self._state.ledger, self._state.blocktree)
        self._state.pacemaker = Pacemaker(self._state.validator_id, self._state.replicas, self._state.blocktree, self._state.safety, self._state.config['nfaulty'], self._state.config['delta'], self.send_timeout_msg)
        self._state.mempool = MemPool(self._state.validator_id)
        self._state.leader_election = LeaderElection(self._state.config['round_leaders'], self._state.validator_id, self._state.replicas, self._state.ledger, self._state.pacemaker, self._state.config['window_size'], self._state.config['exclude_size'])
        Cryptography.private_key = self._state.private_key
        Cryptography.replicas = self._state.replicas
        Cryptography.public_keys_validators = self._state.public_keys_validators
        if (self._state.config['failure_config'].seed is None):
            self._state.config['failure_config'].seed = random.randint(10000, 100000)
            LOGGER.log_action('Generated a seed for failure config', self._state.config['failure_config'].seed)
        random.seed(self._state.config['failure_config'].seed)

    def run(self):
        self._state.pacemaker.start_timer(1)
        LOGGER.log(self._state.replicas[self._state.validator_id])
        super()._label('_st_label_535', block=False)
        _st_label_535 = 0
        while (_st_label_535 == 0):
            _st_label_535 += 1
            if PatternExpr_546.match_iter(self._ValidatorReceivedEvent_0, _BoundPattern552_=self.parent(), SELF_ID=self._id):
                _st_label_535 += 1
            else:
                super()._label('_st_label_535', block=True)
                _st_label_535 -= 1
        self._state.pacemaker.stop_timer(self._state.pacemaker.current_round)
        self.output('Validator', self._state.validator_id, 'is exiting')

    def setattr(self, attr, value):
        if (attr == 'current_round'):
            self._state.pacemaker.current_round = value
        elif (attr == 'highest_vote_round'):
            self._state.safety.set_highest_vote_round(value)
        else:
            self.output('error: Validator.setattr: unsupported attribute')

    def send_timeout_msg(self, timeout_msg):
        LOGGER.log('Validator: send_timeout_message', timeout_msg)
        self.send(('Timeout', {'from': self._state.validator_id, 'to': self._state.replicas, 'payload': timeout_msg}), to=self._state.network_playground)
        LOGGER.log_event('Sent', 'Timeout', timeout_msg, self._state.replicas)

    def process_certificate_qc(self, qc):
        LOGGER.log('Validator: process_certificate_qc', qc)
        'Block-Tree.process qc(qc)'
        self._state.blocktree.process_qc(qc)
        LOGGER.log('Validator: process_certificate_qc recent_committed_block', len(self._state.recently_committed_block_ids))
        if (len(self._state.recently_committed_block_ids) > 0):
            for block_id in self._state.recently_committed_block_ids:
                for txn in self._state.id_block[block_id].payload:
                    request_id = txn['req_id']
                    resp = {'req_id': request_id, 'resp_status': 'success'}
                    self.send(('Response', resp), to=txn['client'])
                    LOGGER.log_event('Sent', 'Response', resp, txn['client'])
                    self._state.request_cache[request_id] = resp
            self._state.recently_committed_block_ids.clear()
        'LeaderElection.update leaders(qc)'
        self._state.leader_election.update_leaders(qc)
        'Pacemaker.advance round(qc.vote info.round)'
        self._state.pacemaker.advance_round_qc(qc)
        LOGGER.log('Validator: process_certificate_qc ended', qc)

    def process_new_round_event(self, last_tc):
        LOGGER.log('Validator: process_new_round_event', last_tc)
        'if u = LeaderElection.get leader(Pacemaker.current round) then'
        if (self._state.replicas[self._state.validator_id] == self._state.leader_election.get_leader(self._state.pacemaker.current_round)):
            print(self._state.replicas[self._state.validator_id], self._state.leader_election.get_leader(self._state.pacemaker.current_round))
            if (self._state.mempool.peek_pool() == 0):
                print(self._state.mempool.pending_txns)
                self._state.should_start_new_round = True
                prev_block = self._state.id_block[self._state.blocktree.high_qc.vote_info.id]
                prev_block_txn_len = len(prev_block.payload)
                prev_qc = prev_block.qc
                if (not (prev_qc is None)):
                    prev_prev_block = self._state.id_block[prev_qc.vote_info.id]
                    prev_prev_block_txn_len = len(prev_prev_block.payload)
                else:
                    prev_prev_block_txn_len = 0
                if ((prev_block_txn_len == 0) and (prev_prev_block_txn_len == 0)):
                    LOGGER.log('Validator: process_new_round_event: returned as no transactions in mempool', last_tc)
                    return
            'b ← Block-Tree.generate block( MemPool.get transactions(),\n                    Pacemaker.current round )'
            block = self._state.blocktree.generate_block(self._state.mempool.get_transactions(), self._state.pacemaker.current_round)
            LOGGER.log_action('Created a new block', block)
            'broadcast ProposalMsghb, last tc, Block-Tree.high commit qci'
            proposal_msg = ProposalMsg(block=block, last_round_tc=last_tc, high_commit_qc=self._state.blocktree.high_commit_qc, validator=self._state.validator_id)
            print('Proposal sending ', self._state.network_playground)
            self.send(('Proposal', {'from': self._state.validator_id, 'to': self._state.replicas, 'payload': proposal_msg}), to=self._state.network_playground)
            LOGGER.log_event('Sent', 'Proposal', proposal_msg, self._state.replicas)
        LOGGER.log('Validator: process_new_round_event ends', None)

    def _Validator_handler_909(self, proposal_msg, p):
        LOGGER.log_event('Received', 'Proposal', proposal_msg, p)
        signature_verified = Cryptography.get_verified_message(proposal_msg.signature, self._state.public_keys_validators[p])
        if (not (signature_verified is None)):
            LOGGER.log_action('Verified ProposalMsg signature', True)
            self._state.should_start_new_round = False
            if ((not (proposal_msg.block.qc is None)) and (not (p == self._state.replicas[self._state.validator_id]))):
                'process certificate qc(P.block.qc)'
                self.process_certificate_qc(proposal_msg.block.qc)
            if (not (proposal_msg.high_commit_qc is None)):
                'process certificate qc(P.high commit qc)'
                self.process_certificate_qc(proposal_msg.high_commit_qc)
            'Pacemaker.advance round tc(P.last round tc)'
            self._state.pacemaker.advance_round_tc(proposal_msg.last_round_tc)
            'round ← Pacemaker.current round'
            round = self._state.pacemaker.current_round
            'leader ← LeaderElection.get leader(current round)'
            leader = self._state.leader_election.get_leader(round)
            'if P.block.round 6= round ∨ P.sender 6= leader ∨ P.block.author 6= leader then\n                    return'
            if ((not (proposal_msg.block.round == round)) or (not (self._state.replicas[proposal_msg.sender] == leader)) or (not (self._state.replicas[proposal_msg.block.author] == leader))):
                LOGGER.log('ROUND PROPOSAL EARLY EXIT', proposal_msg.block.round, round, self._state.replicas[proposal_msg.sender], leader)
                return
            if (not (p == self._state.replicas[self._state.validator_id])):
                if (not self._state.mempool.validate_and_remove_transactions(proposal_msg.block.payload)):
                    LOGGER.log('Not processing the Proposal message as transactions are not valid', None)
                    return
            if (len(proposal_msg.block.payload) == 0):
                self._state.should_start_new_round = True
            'Block-Tree.execute and insert(P) // Adds a new speculative state to the Ledger'
            self._state.blocktree.execute_and_insert(proposal_msg.block)
            'vote msg ← Safety.make vote(P.block, P.last round tc)'
            vote_msg = self._state.safety.make_vote(proposal_msg.block, proposal_msg.last_round_tc)
            'if vote msg != ⊥ then\n                    send vote msg to LeaderElection.get leader(current round + 1)'
            if (not (vote_msg is None)):
                next_leader = self._state.leader_election.get_leader((round + 1))
                self.send(('Vote', {'from': self._state.validator_id, 'to': next_leader, 'payload': vote_msg}), to=self._state.network_playground)
                LOGGER.log_event('Sent', 'Vote', vote_msg, next_leader)
        else:
            LOGGER.log_action('Verified ProposalMsg signature', False)
    _Validator_handler_909._labels = None
    _Validator_handler_909._notlabels = None

    def _Validator_handler_1170(self, vote_msg, p):
        LOGGER.log_event('Received', 'Vote', vote_msg, p)
        signature_verified = Cryptography.get_verified_message(vote_msg.signature, self._state.public_keys_validators[p])
        if (not (signature_verified is None)):
            LOGGER.log_action('Verified VoteMsg signature', True)
            'qc ← Block-Tree.process vote(M)'
            qc = self._state.blocktree.process_vote(vote_msg)
            'if qc != ⊥ then'
            if (not (qc is None)):
                LOGGER.log_action('Generated a Quorum Certificate', qc)
                'process certificate qc(qc)\n                process new round event(⊥)'
                self.process_certificate_qc(qc)
                self.process_new_round_event(None)
        else:
            LOGGER.log_action('Verified VoteMsg signature', False)
        LOGGER.log('Received VoteMsg ends g', None)
    _Validator_handler_1170._labels = None
    _Validator_handler_1170._notlabels = None

    def _Validator_handler_1260(self, timeout_msg, p):
        LOGGER.log_event('Received', 'Timeout', timeout_msg, p)
        signature_verified = Cryptography.get_verified_message(timeout_msg.tmo_info.author_signature, self._state.public_keys_validators[p])
        if (not (signature_verified is None)):
            LOGGER.log_action('Verified TimeoutMsg signature', True)
            'process certificate qc(M.tmo info.high qc)\n            process certificate qc(M.high commit qc)'
            self.process_certificate_qc(timeout_msg.tmo_info.high_qc)
            self.process_certificate_qc(timeout_msg.high_commit_qc)
            'Pacemaker.advance round tc(M.last round tc)'
            self._state.pacemaker.advance_round_tc(timeout_msg.last_round_tc)
            'tc ← Pacemaker.process remote timeout(M)'
            tc = self._state.pacemaker.process_remote_timeout(timeout_msg)
            'if tc != ⊥ then'
            if (not (tc is None)):
                LOGGER.log_action('Generated a Timeout Certificate', tc)
                'process certificate qc(qc)\n                process new round event(⊥)'
                self._state.pacemaker.advance_round_tc(tc)
                self.process_new_round_event(tc)
        else:
            LOGGER.log_action('Verified TimeoutMsg signature', False)
    _Validator_handler_1260._labels = None
    _Validator_handler_1260._notlabels = None

    def _Validator_handler_1369(self, signed_req, client):
        req = Cryptography.get_verified_message(signed_req, self._state.public_keys_clients[client])
        LOGGER.log_event('Received', 'Request', req, client)
        if (not (req is None)):
            if (req['req_id'] in self._state.request_cache):
                response = self._state.request_cache[req['req_id']]
                self.send(('Response', response), to=client)
                LOGGER.log_event('Sent', 'Cached Response', response, client)
                return
            req['client'] = client
            self._state.mempool.add_transaction(req)
            if self._state.should_start_new_round:
                self.process_new_round_event(None)
                self._state.should_start_new_round = False
        else:
            LOGGER.log_action('Verified Client Request signature', False)
    _Validator_handler_1369._labels = None
    _Validator_handler_1369._notlabels = None

class ValidatorFI(Validator, da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._events.extend([])

    def get_failure_config(self, message, to):
        for failure_config in self._state.config['failure_config'].failures:
            if ((failure_config.fail_type == FailType.SetAttr) and (self._state.validator_id < (len(self._state.replicas) - self._state.config['nfaulty']))):
                continue
            if (not (failure_config.round == self._state.pacemaker.current_round)):
                continue
            if (failure_config.src == 'leader'):
                if (not (self._state.leader_election.get_leader(self._state.pacemaker.current_round) == self._state.replicas[self._state.validator_id])):
                    continue
            elif ((not (failure_config.src == '_')) and (not (failure_config.src == self._state.validator_id))):
                continue
            if (failure_config.dest == 'leader'):
                if ((failure_config.msg_type == MsgType.Vote) and (not (self._state.leader_election.get_leader((self._state.pacemaker.current_round + 1)) == to))):
                    continue
                if ((not (failure_config.msg_type == MsgType.Vote)) and (not (self._state.leader_election.get_leader(self._state.pacemaker.current_round) == to))):
                    continue
            elif ((not (failure_config.dest == '_')) and (not (self._state.replicas[failure_config.dest] == to))):
                continue
            if ((not (failure_config.msg_type == MsgType.Wildcard)) and (not (failure_config.msg_type.name == message[0]))):
                continue
            if (random.random() < (1 - failure_config.prob)):
                return None
            else:
                return failure_config
        return None

    def send_msg_delayed(self, message, to, val):
        time.sleep(val)
        super().send(message, to)

    def send(self, message, to):
        dests = [to]
        if (type(to) == list):
            dests = to
        for dest in dests:
            failure_config = self.get_failure_config(message, dest)
            if (failure_config is None):
                super().send(message, dest)
            else:
                LOGGER.log_action('Injecting fault', [failure_config.fail_type.name, message, dest])
                if (failure_config.fail_type == FailType.MsgLoss):
                    LOGGER.log('ValidatorFI.send', 'message dropped')
                elif (failure_config.fail_type == FailType.Delay):
                    LOGGER.log('ValidatorFI.send', 'message delayed')
                    delay_thread = threading.Thread(target=self.send_msg_delayed, args=(message, dest, failure_config.val))
                    delay_thread.start()
                elif (failure_config.fail_type == FailType.SetAttr):
                    LOGGER.log('ValidatorFI.send', 'config changed')
                    super().setattr(failure_config.attr, failure_config.val)
                else:
                    self.output('error: ValidatorFI.send: unsupported fail type', failure_config.fail_type)
