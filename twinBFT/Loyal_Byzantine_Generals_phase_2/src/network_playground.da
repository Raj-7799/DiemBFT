import json
from logger_util import LOGGER
from collections import defaultdict


class NetworkPlayground(process):


    def setup(twin_config:dict,validators,number_of_nodes:int,public_keys_validators,public_keys_clients):

        config_id=0
        LOGGER.process_id = "NetworkPlayGround"
        LOGGER.filename = '../logs/config' + str(config_id) + '/' \
            + LOGGER.process_id + ".log"

        LOGGER.log_action("Initial configuration", twin_config)

        self.leaders =  twin_config["round_leaders"]
        self.partitions =  twin_config["round_partitions"]
        self.public_keys_validators= public_keys_validators
        self.number_of_nodes = number_of_nodes
        self.number_of_twins = twin_config["number_of_twins"]
        #List of validators 
        self.validators =validators 
        self.state = defaultdict(dict)
        self.completed = False

        print("Validators count {} {}".format(len(validators), number_of_nodes))


    def run():
        output("Creating NetworkPlayGround  ",self.completed)
        await(self.completed == True)
        output("Informing parent about Exiting  NetworkPlayGround  ",parent())
        output("Exiting  NetworkPlayGround 1 ",parent())
        # in case parent process is not sending done but rounds in partition are over,
        send(('DonePlayground',), to=parent())
        output("Exiting  NetworkPlayGround 2 ",parent())


    def receive(msg=('Timeout', msg), from_=p):
        LOGGER.log_event("Playground: Received  from {} for round {}".format(self.validators.index(p),msg["current_round"]), "Timeout", "msg", p)
        print("Playground: Received  from {} {}".format(self.validators.index(p),p))
        if self.completed:
            print("Timeout ")
            return
            
        request  = {
            "type": 'Timeout',
            "_from": msg["from"],
            "_to" : msg["to"],
            "payload": msg["payload"],
            "current_round":msg["current_round"],
            "is_broadcast": True

        }

        process_request(request)



    def receive(msg=('Proposal', msg), from_=p):
        LOGGER.log_event("Playground: Received  from {} for round {} ".format(self.validators.index(p),msg["current_round"]), "Proposal", "msg", p)
        print("Playground: Received  from {} {}".format(self.validators.index(p),p))
        if self.completed:
            return

        request  = {
            "type": 'Proposal',
            "_from": msg["from"], 
            "_to" : msg["to"],
            "payload": msg["payload"],
            "current_round":msg["current_round"],
            "is_broadcast": True
        }

        process_request(request)

    def receive(msg=('Vote', msg), from_=p):
        LOGGER.log_event("Playground: Received  from {} for round {} ".format(self.validators.index(p),msg["current_round"]), "Vote", "msg", p)
        print("Playground: Received  from {} {}".format(self.validators.index(p),p))
        if self.completed:
            return

        request  = {
            "type": 'Vote',
            "_from": msg["from"],
            "_to" : msg["to"],
            "payload": msg["payload"],
            "current_round":msg["current_round"],
            "is_broadcast": False
        }
        
        process_request(request)

    def process_request(request):
        if self.completed:
            print("process_request")
            return
        
        request_type = request["type"]
        _from =  request["_from"]
        _to =  request["_to"]
        payload = request["payload"]
        
        current_round = request["current_round"]

        if current_round == len(self.partitions) + 1:
            self.completed = True
            LOGGER.log_event("Playground: process_request completed = {}  {} {} ".format(current_round,self.completed,self.state), request_type, "payload",_from)
            return

        network_partition =  self.partitions[current_round-1]

        LOGGER.log(request,payload)

        LOGGER.log_event("Playground:  process_request ", request_type, "payload", _from)
        sender_id = _from

        is_broadcast = request["is_broadcast"]
        if is_broadcast:

            for node_id,node in enumerate(self.validators):#.items():

                twin_id =  node_id + self.number_of_nodes
                if same_partition(current_round,network_partition,sender_id, node_id):
                    LOGGER.log_event("Playground: process_request broadcast Send request from  {} to {} for round {}".format(sender_id,node_id,current_round), request_type, payload, node)
                    print("Playground: process_request Round: {}  Send request {} to {}  {}".format(current_round,sender_id,node_id, request_type))

                    send((request_type, (payload,sender_id,current_round)), to=node)

                if twin_id < len(self.validators) and same_partition(current_round,network_partition,twin_id,node_id):
                    LOGGER.log_event("Playground: process_request broadcast Send request from Twin  {} to {} for round {}".format(twin_id,node_id,current_round), request_type, payload, node)
                    print("Playground: process_request Round: {} Send request twin : {} to {}   {} ".format(current_round,twin_id,node_id, request_type))
                    
                    send((request_type, (payload,twin_id,current_round)), to=node)
              
        else:
            print("Receiver ID ",_to,len(self.validators),self.validators)
            receiverID = self.validators.index(_to)
            if same_partition(current_round,network_partition,sender_id,receiverID):
                LOGGER.log_event("Playground: process_request Send request from {} to {} for round {} ".format(sender_id,receiverID,current_round), request_type, payload, _to)
                send((request_type, (payload,sender_id,current_round)), to=_to)

            
            twin_id = sender_id +self.number_of_nodes

            if twin_id < len(self.validators)  and same_partition(current_round,network_partition,twin_id,receiverID):
                LOGGER.log_event("Playground: process_request Send request from Twin {} to {} for round {}".format(twin_id,receiverID,current_round),  request_type, payload, _to)

                send((request_type, (payload,twin_id,current_round)), to=_to )
            
            # message originating from some now of node which has a twin node
            if receiverID+self.number_of_nodes < len(self.validators) and same_partition(current_round,network_partition,sender_id,receiverID+self.number_of_nodes):
                LOGGER.log_event("Playground: process_request Send request from {} to {} for round {}".format(sender_id,receiverID+self.number_of_nodes,round), request_type, payload, _to)

                send((request_type, (payload,sender_id,current_round)), to=self.validators[receiverID+self.number_of_nodes])
            
        
        state[sender_id][current_round]=+1

    def same_partition(_round,round_network_partition,sender,receiver):

        current_partitions =round_network_partition 

        if( _round in state[sender].keys() ):
            partition_id =  min( state[sender][_round]-1, len(current_partitions)-1 )
        else:
            state[sender][_round]=1
            partition_id=0
            print("state sender {} state[sender] {} state {} ".format(sender,state[sender],state))

        
        for partition in current_partitions[partition_id]:
            print("partition  ",current_partitions,partition,type(partition),sender,receiver)
            #LOGGER.log_event("Playground: process_request receiver {} sender {} ".format(receiver,sender) ,_round, partition,sender)
            if sender in partition and receiver in partition:
                return True              
        return False
        

        








