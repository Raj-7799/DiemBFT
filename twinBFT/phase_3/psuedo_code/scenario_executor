Module ScenarioExecutor{
 num_nodes, //total number of nodes excluding twin
 twin_nodes, //nodes for which to create twins
 round_partitions, //Configuration of Partition for each round
 round_leaders //Leader for each round
 num_of_rounds //number of rounds for which the network playground should run
 id // file id of Configuration
 mode // mode of operation
 timeout // some timeout for the scenario executor
 reached_timeout <- False

 // if some id is given load the configuration
 if id != None:
  round_partitions, round_leaders = load_from_json(id)

 current_round <- 0
  //Initialise Network Partition

  Function start()
    // if some id is given load the configuration
    // this indicates offline mode where reading config is required
    if id != None:
      round_partitions, round_leaders = load_from_json(id)
  
    NetworkPlaygroud <- NetworkPlayground(round_partitions, number_of_nodes)
    F <- |twin_nodes| / 2
    Keys <- generateKeys(num_nodes)
    Nodes <- ∅

    //Run the Algorithm for Number of round 
    np <- NetworkPlayground()
    //We need to pass Partition Con
    for i in 1...(num_nodes+F):
    //This assigns same cryptographic keys to twins
      Nodes <- spawn(i, Keys[i % num_nodes], round_leaders, np) 

    // start a timer
    start_timer(timeout, onTimeout)
    //Wait till we receive a callbacks from Network Playground with round exceeding the limit 
    await (current_round<=num_of_rounds + 3 and !reachedTimeout);

    for i in 1...(num_nodes+F):
      // terminate all nodes as all rounds has been done
      terminate(i)

  OnReceive(M){
    current_round=M.round;
  }

  onTimeout() {
    reachedTimeout <- True
  }

  Function verify(){
    SafetyCheck() && 
    LivenessCheck()
  }
    
  Function SafetyCheck(){
    //check if there are differing commits
    for node in num_nodes:
      ledger = ∅

      if node in twin_nodes:
        // condition required so that twin ledger is also included
        twin = node + total_nodes
        // returns ledger as a sequential list
        twin_ledger = getLedger(twin)
        ledger = twin_ledger
        
      // choose any one of complete ledger which is ledger or twin_ledger
      ledger = getLedger(node) or ledger

      if ledger == ∅:
        continue
      
      count += 1
      for other_node in num_nodes:
        if node != other_node:
          other_ledger = getLedger(node)
          if other_ledger == ∅:
            continue
          
          // perform sequential check for each block commited
          // order as well as block contenets are verified
          if ledger != other_ledger:
            // ledger are not consistent
            return False
      
    if count < (2 * |twin_nodes| / 2) + 1:
      // less than 2 * f + 1 nodes commited 
      // this will also do a liveness check here itself although
      // we have defined another explicit function for this check
      return False
    
    return True
  }
    

  Function LivenessCheck(){
    //check if atleast be one commited block for every node
    count == 0
    for node in num_nodes:
    // returns ledger as a sequential list of block commits
      ledger = node.getLedger()
      
      if node in twin_nodes:
        // condition required so that twin ledger is also included
        twin = node + total_nodes
        twin_ledger = getLedger(twin)
        // choose any one of complete ledger which is ledger or twin_ledger
        ledger = twin_ledger or ledger
      
      //if ledger has content increment
      if |ledger| != 0:
        count += 1
      
    // check if count is greater than or equal to 2 * f + 1
    return count >= (2 * |twin_nodes| / 2) + 1
  }
}