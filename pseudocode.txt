Validity check for Crytography

Function sign_object(msg,private_key):
    serialized_object = serialize the message
    hex_signed_object = sign serialized_object using private_key and hex-enccode the result
    return hex_signed_object


Function verifying_message(signed_msg_object):
    decoded_signature = decode the signed_msg from hex to bytes
    verifying_key =  sender_public_key
    if verify(decoded_signature,verifying_key)
        return True
    else:
        return false






Syncing up of replicas that got behind:

BlockTree:

    Function execute_and_insert(block):
    	if current_round + 1 < block.round:
    		start_sync(block.id)
    		 
        if current_round <= max{highest_vote_round,qc.vote_info.round} then:
            // for a replica lagging behind its highest_vote_round will be less that the qc_round 
            // And qc_round will be greater than block round
            send sync event to every other replica
            
    
    Procedure start_sync(current_round,block.round):
    	last_commited_block =  Ledger.get_last_commited_block()
    	SyncMsgRequest(last_commited_block,sender=u)



Main: EventLoop

	Procedure start_event_processing(M)
		if M is a SyncMsgRequest process_sync(M)
		if M is a BlockSyncMessage process_block(M)

Main:
	Procedure process_sync(M):

	    if u!=M.sender:
		next_block = Ledger.get_next_block(M.last_committed.id):
		last_committed_block = Ledger.get_last_commited()
		BlockSyncMessage(next_block,last_committed_block,sender=M.sender)

	    
	Procedure process_block(M):

	    if u==M.sender:
		pending_blocks[M.next_block.id]++
		candidate_block_to_commit[M.next_block.id]=M.next_block
		Ledger.speculate(M.next_block.vote_info.id, M.next_block.id,M.next_block)
		if pending_blocks[M.next_block.id] == 2*f + 1
		    // wait for a 2*f+1 blocks before we commit it to the ledger 
		    Ledger.commit(M.next_block.id)
		    Pacemaker.round = M.next_block.round  // to sync the round number so that it can participate in the election 
		    if M.last_commited_block.id != M.next_block.id
		    	SyncMsgRequest(Ledger.get_last_commited,sender=u)




// client requests: de-duplication; include appropriate requests in proposals

Client:

    MainLoop:Client_EventLoop
        loop: wait for next event M ; Main.start event processing(M)
        Procedure start_event_processing(M)
            if M is response then process_result(M)
            if M is timeout then on_timeout(M)

    Function sendMessage(message):
        send request for message 
        start_timer()

    Function on_timeout(M):
        sendMessage(M.message)

    start_timer():
        while(current_time < max_timeout):
            current_time = get_time_elapsed(start_time)
            process_result()
    
    Function process_result(M):

        if validate_response_signature(M): // use cryto verify to validate the message
            if process_command[cmd.id][response.id] == f+1:
                transaction_id = response.id
        

MemPool:
	requestQueue:Queue
	process_transcation:dict() // keeps track of currently processing transcations
	
	insert_command(command):
		if command not in process_transcation: // to prevent duplication of request incase a client timeouts and resends the message
		    insert command in requestQueue
	
		    


    
