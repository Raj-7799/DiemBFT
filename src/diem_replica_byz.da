import BlockTree as bt

from client_info import ClientInfo
import mempool
import Message
from replica_info import ReplicaInfo
import Pacemaker as PM
import PacemakerByz as pmbyz
import Safety as sf
import SafetyByz as sfbyz
import leader_election as le
import ProposalMsg as plm
import pickle
import sys
import os
import Util
from diembft_logger import get_logger
import time

from diem_replica import Replica

diem_logger = get_logger(os.path.basename(__file__))

class ReplicaByz(process,Replica):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]"):#,networkByzantine,networkByzantineSeed,processByzantine,processByzantineSeed,degreeOfByzantine):
        output("Spwaning process for replica {}".format(replicaID))
        

    def process_next_round_event(last_tc):
        # diem_logger.debug("[replicaID {}] New Round event {}".format(self.replicaID, self.replicaID == leaderElection.get_leader(paceMaker.current_round)))
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            transaction = memPool.get_transactions()
            output("Faulty Leader sleeping  {}".format(self.replicaID))
            # self.time.sleep(10000)
            output("Faulty Leader woke up  {}".format(self.replicaID))

 
        
            if not transaction:
                self.waiting = True
                self.timedOut = False
                output("[replicaID {}] Waiting for transactions in mempool".format(self.replicaID))
                output("[replicaID {}] Mempoool state {}".format(self.replicaID, self.memPool.print()))
                --request
                await(self.waiting == False)
            
            if self.timedOut:
                output("[replicaID {}] Timed out while waiting for transaction".format(self.replicaID))
                return

            if transaction is None:
                self.waiting = False
                self.timedOut = False
                transaction = memPool.get_transactions()
                output("[replicaID {}] Transaction after waiting {}".format(self.replicaID, transaction))

            block = blockTree.generate_block(transaction, paceMaker.current_round)
            diem_logger.info("[replicaID {}] Generated block with block_id {} for transaction {} at round {}".format(self.replicaID, block.id, transaction, paceMaker.current_round))
            diem_logger.info("[replicaID {}] Mempool state {}".format(self.replicaID, self.memPool))
            proposal_msg = plm.ProposalMsg(block, last_tc, blockTree.high_commit_qc, self.privateKey, self.publicKey)
            diem_logger.info("[replicaID {}] Broadcasting proposal message for block with block_id {} at round {}".format(self.replicaID, block.id, paceMaker.current_round))
            for _, replicaInfo in self.replicaInfos.items():
                SIGNED_MSG = Util.sign_object_dup(proposal_msg, self.privateKey)
                send(("process_proposal_msg", [proposal_msg, SIGNED_MSG]), to=replicaInfo.process)
 