# -*- generated by 1.1.0b15 -*-
import da
PatternExpr_669 = da.pat.ConstantPattern('client_end')
PatternExpr_954 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('cmd')])
PatternExpr_961 = da.pat.FreePattern('source')
PatternExpr_1072 = da.pat.TuplePattern([da.pat.ConstantPattern('process_proposal_msg'), da.pat.FreePattern('P')])
PatternExpr_1079 = da.pat.FreePattern('source')
PatternExpr_1378 = da.pat.TuplePattern([da.pat.ConstantPattern('process_vote_msg'), da.pat.FreePattern('M')])
PatternExpr_1385 = da.pat.FreePattern('source')
PatternExpr_1485 = da.pat.TuplePattern([da.pat.ConstantPattern('process_timeout_msg'), da.pat.FreePattern('M')])
PatternExpr_1492 = da.pat.FreePattern('source')
PatternExpr_1608 = da.pat.ConstantPattern('client_end')
PatternExpr_1612 = da.pat.FreePattern('source')
PatternExpr_1623 = da.pat.TuplePattern([da.pat.ConstantPattern('validate'), da.pat.FreePattern('block_id')])
PatternExpr_1630 = da.pat.FreePattern('source')
PatternExpr_1697 = da.pat.TuplePattern([da.pat.ConstantPattern('BlockSyncMessage'), da.pat.FreePattern('M')])
PatternExpr_1704 = da.pat.FreePattern('source')
PatternExpr_1871 = da.pat.TuplePattern([da.pat.ConstantPattern('SyncMsgRequest'), da.pat.FreePattern('M')])
PatternExpr_1878 = da.pat.FreePattern('source')
_config_object = {}
import BlockTree as bt
from client_info import ClientInfo
import mempool
import Message
from replica_info import ReplicaInfo
import Pacemaker as PM
import Safety as sf
import leader_election as le
import ProposalMsg as plm
import pickle
import sys
import os
import Util
import time
from collections import defaultdict
import random

class Replica(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ReplicaReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_669, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_954, sources=[PatternExpr_961], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_953]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1072, sources=[PatternExpr_1079], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1071]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_1378, sources=[PatternExpr_1385], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1377]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_1485, sources=[PatternExpr_1492], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1484]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_1608, sources=[PatternExpr_1612], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1607]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_1623, sources=[PatternExpr_1630], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1622]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_1697, sources=[PatternExpr_1704], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1696]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_1871, sources=[PatternExpr_1878], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1870])])

    def setup(self, replicaID, replicaInfos, faulty_replica_count, replica_count, delta, privateKey, clientInfos, specialArgs, **rest_1927):
        super().setup(replicaID=replicaID, replicaInfos=replicaInfos, faulty_replica_count=faulty_replica_count, replica_count=replica_count, delta=delta, privateKey=privateKey, clientInfos=clientInfos, specialArgs=specialArgs, **rest_1927)
        self._state.replicaID = replicaID
        self._state.replicaInfos = replicaInfos
        self._state.faulty_replica_count = faulty_replica_count
        self._state.replica_count = replica_count
        self._state.delta = delta
        self._state.privateKey = privateKey
        self._state.clientInfos = clientInfos
        self._state.specialArgs = specialArgs
        self._state.replicaID = self._state.replicaID
        self._state.replicaInfos = self._state.replicaInfos
        self._state.fCount = self._state.faulty_replica_count
        self._state.rCount = self._state.replica_count
        self._state.tDelta = self._state.delta
        self._state.privateKey = self._state.privateKey
        self._state.publicKey = self.get_replica_public_key(self._state.replicaID)
        self._state.clientInfos = self._state.clientInfos
        self._state.memPool = mempool.MemPool(self.OutputMempool)
        self._state.firstRequestProcess = False
        self._state.waiting = False
        self._state.timedOut = False
        self._state.specialArgs = self._state.specialArgs
        self._state.blockTree = bt.BlockTree(self._state.fCount, self._state.replicaID, self._state.privateKey, self.get_replica_public_key(self._state.replicaID), self._state.memPool, self.client_response_handler, self.send_sync_message, self.OutputLoggerBlockTree)
        self._state.safety = sf.Safety(self._state.blockTree, self.get_replica_public_keys(), self._state.replicaID, self.OutputLoggerSafety)
        self._state.paceMaker = PM.Pacemaker(self._state.safety, self._state.blockTree, self._state.tDelta, self._state.fCount, self.pacemaker_broadcast_timeout, self._state.replicaID, self.OutputLoggerPacemaker)
        self._state.leaderElection = le.LeaderElection(self._state.fCount, self._state.paceMaker, self._state.blockTree._ledger, self.get_replica_ids(), self._state.replicaID, self.OutputLeaderElection)
        self._state.pending_blocks = defaultdict(list)
        self.OutputReplica('__init__')

    def run(self):
        super()._label('_st_label_666', block=False)

        def ExistentialOpExpr_667():
            for (_, _, _ConstantPattern680_) in self._ReplicaReceivedEvent_0:
                if (_ConstantPattern680_ == 'client_end'):
                    if True:
                        return True
            return False
        _st_label_666 = 0
        while (_st_label_666 == 0):
            _st_label_666 += 1
            if ExistentialOpExpr_667():
                _st_label_666 += 1
            else:
                super()._label('_st_label_666', block=True)
                _st_label_666 -= 1

    def OutputLoggerPacemaker(self, log):
        self.output('[Pacemaker][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def OutputLoggerSafety(self, log):
        self.output('[Safety][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def OutputLoggerBlockTree(self, log):
        self.output('[BlockTree][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def OutputLeaderElection(self, log):
        self.output('[LeaderElection][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def OutputReplica(self, log):
        self.output('[Replica][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def OutputMempool(self, log):
        self.output('[Mempool][ReplicaID-{}][{}]'.format(self._state.replicaID, log))

    def broadcast_helper(self, method, message):
        for (_, replicaInfo) in self._state.replicaInfos.items():
            self.send((method, message), to=replicaInfo.process)

    def client_response_handler(self, request):
        self.send(('transaction_committed', request), to=request[1].source)

    def get_replica_info(self, replicaID):
        for (_, replicaInfo) in self._state.replicaInfos.items():
            if (replicaInfo.replicaID == replicaID):
                return replicaInfo

    def get_replica_ids(self):
        replicaIDs = []
        for (_, replicaInfo) in self._state.replicaInfos.items():
            replicaIDs.append(replicaInfo.replicaID)
        return replicaIDs

    def pacemaker_broadcast_timeout(self, tmo_message):
        self.OutputReplica('[pacemaker_broadcast_timeout] Entry')
        SIGNED_MSG = Util.sign_object_dup(tmo_message, self._state.privateKey)
        self.broadcast_helper('process_timeout_msg', [tmo_message, SIGNED_MSG])
        self.OutputReplica('[pacemaker_broadcast_timeout] Exit')

    def get_replica_public_key(self, replicaID):
        replicaInfo = self.get_replica_info(replicaID)
        return replicaInfo.public_key

    def get_replica_public_keys(self):
        keys = []
        for (_, replicaInfo) in self._state.replicaInfos.items():
            keys.append(replicaInfo.public_key)
        return keys

    def process_certificate(self, qc):
        self.OutputReplica('[process_certificate] Entry Processing QC {} for vote_info {} at round {}'.format(qc, qc.vote_info.id, self._state.paceMaker.current_round))
        if qc.verify_self_signature_qc():
            self._state.blockTree.process_qc(qc)
            self._state.leaderElection.update_leaders(qc)
            self._state.paceMaker.advance_round_qc(qc)
            self.OutputReplica('[process_certificate] Exit Processing QC {} for vote_info {} at round {}'.format(qc, qc.vote_info.id, self._state.paceMaker.current_round))
        else:
            self.OutputReplica('[process_certificate] Exit QC invalid')

    def process_next_round_event(self, last_tc):
        self.OutputReplica('[process_next_round_event] Entry')
        if (self._state.replicaID == self._state.leaderElection.get_leader(self._state.paceMaker.current_round)):
            transaction = self._state.memPool.get_transactions()
            if (not transaction):
                self._state.waiting = True
                self._state.timedOut = False
                self.OutputReplica('Waiting for transactions in mempool')
                self.OutputReplica('Mempoool state {}'.format(self._state.memPool.print()))
                super()._label('request', block=False)
                _st_label_808 = 0
                while (_st_label_808 == 0):
                    _st_label_808 += 1
                    if (self._state.waiting == False):
                        _st_label_808 += 1
                    else:
                        super()._label('request', block=True)
                        _st_label_808 -= 1
            if self._state.timedOut:
                self.OutputReplica('Timed out while waiting for transaction')
                return
            if (transaction is None):
                self._state.waiting = False
                self._state.timedOut = False
                transaction = self._state.memPool.get_transactions()
                self.OutputReplica('Transaction after waiting {}'.format(transaction))
            block = self._state.blockTree.generate_block(transaction, self._state.paceMaker.current_round)
            self.OutputReplica('Generated block with block_id {} for transaction {} at round {}'.format(block.id, transaction, self._state.paceMaker.current_round))
            self.OutputReplica('Mempool state {}'.format(self._state.memPool))
            proposal_msg = plm.ProposalMsg(block, last_tc, self._state.blockTree.high_commit_qc, self._state.privateKey, self._state.publicKey)
            self.OutputReplica('Broadcasting proposal message for block with block_id {} at round {}'.format(block.id, self._state.paceMaker.current_round))
            for (_, replicaInfo) in self._state.replicaInfos.items():
                SIGNED_MSG = Util.sign_object_dup(proposal_msg, self._state.privateKey)
                self.send(('process_proposal_msg', [proposal_msg, SIGNED_MSG]), to=replicaInfo.process)
        self.OutputReplica('[process_next_round_event] Exit')

    def send_sync_message(self, sync_status_object):
        self.OutputReplica('[send_sync_message] Entry broadcast message')
        for (_, replicaInfo) in self._state.replicaInfos.items():
            self.send(('SyncMsgRequest', sync_status_object), to=replicaInfo.process)
        self.OutputReplica('[send_sync_message] Exit')

    def _Replica_handler_953(self, cmd, source):
        self.OutputReplica('[request] Enty Received client request. Inserting cmd {} into mempool of replica'.format(cmd))
        if ((not (cmd.payload == 'empty')) and (not Util.verify_message_dup(cmd.signature, self._state.clientInfos[source].public_key))):
            self.OutputReplica('Received forged client signature')
            self.OutputReplica('[request] Exit')
            return
        else:
            self.OutputReplica('[request] Client signature looks good')
        self.OutputReplica('[request] Waiting state {}'.format(self._state.waiting))
        self._state.waiting = False
        self._state.memPool.insert_command(cmd)
        if (not self._state.firstRequestProcess):
            if (self._state.replicaID == 0):
                self._state.paceMaker.advance_round_qc(self._state.blockTree._high_qc)
            self._state.firstRequestProcess = True
            self.process_next_round_event(None)
        self.OutputReplica('[request] Exit')
    _Replica_handler_953._labels = None
    _Replica_handler_953._notlabels = None

    def _Replica_handler_1071(self, P, source):
        self.OutputReplica('[process_proposal_msg] Entry')
        if (not Util.verify_message_dup(P[1], self._state.replicaInfos[source].public_key)):
            self.OutputReplica('[process_proposal_msg]  Validation Failed')
            return
        else:
            self.OutputReplica('[process_proposal_msg] Validation Successful')
        P = P[0]
        self.OutputReplica('[process_proposal_msg] Received proposal msg with Block ID : {} at round {}'.format(P.block.id, self._state.paceMaker.current_round))
        if (P is None):
            self.OutputReplica('[process_proposal_msg] Received a null proposal')
            return
        self.OutputReplica('[process_proposal_msg] Processing with qc as  {} '.format(P.block.qc))
        self._state.memPool.markState(P.block.payload)
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self._state.paceMaker.advance_round_tc(P.last_round_tc)
        current_round = self._state.paceMaker.current_round
        current_leader = self._state.leaderElection.get_leader(current_round)
        sourceReplica = self._state.replicaInfos[source]
        if ((not (P.block.roundNo == current_round)) or (not (sourceReplica.replicaID == current_leader)) or (not (P.block.author == sourceReplica.replicaID))):
            self.OutputReplica('[process_proposal_msg] Exit Inconsistency {} {} {} {} {} {} {}'.format(P.block.id, P.block.roundNo, current_round, sourceReplica.replicaID, current_leader, P.block.author, sourceReplica.replicaID))
            return
        self._state.blockTree.execute_and_insert(P.block, self._state.paceMaker.current_round)
        vote_message = self._state.safety.make_vote(P.block, P.last_round_tc)
        if vote_message:
            nextLeaderID = self._state.leaderElection.get_leader((current_round + 1))
            self.OutputReplica('[process_proposal_msg] Next leader for the round {} is at replica {}'.format((current_round + 1), nextLeaderID))
            nextLeaderInfo = None
            for (_, replicaInfo) in self._state.replicaInfos.items():
                if (replicaInfo.replicaID == nextLeaderID):
                    nextLeaderInfo = replicaInfo
                    break
            self.OutputReplica('[process_proposal_msg] Exit Sending vote message to next leader : {} for block ID {} at round {}'.format(nextLeaderInfo.replicaID, P.block.id, self._state.paceMaker.current_round))
            SIGNED_MSG = Util.sign_object_dup(vote_message, self._state.privateKey)
            self.send(('process_vote_msg', [vote_message, SIGNED_MSG]), to=nextLeaderInfo.process)
        else:
            self.OutputReplica('[process_proposal_msg] Exit Unable to make vote for block {}'.format(P.block.id))
    _Replica_handler_1071._labels = None
    _Replica_handler_1071._notlabels = None

    def _Replica_handler_1377(self, M, source):
        self.OutputReplica('[process_vote_msg] Entry Inside process_vote_msg receive handler')
        if (not Util.verify_message_dup(M[1], self._state.replicaInfos[source].public_key)):
            self.OutputReplica('[process_vote_msg] Validation Failed')
        else:
            self.OutputReplica('[process_vote_msg] Validation Successful')
        M = M[0]
        self.OutputReplica('[process_vote_msg] Received vote message from {} for block {} at round {}'.format(M.sender, M.vote_info.id, self._state.paceMaker.current_round))
        qc = self._state.blockTree.process_vote(M)
        if qc:
            self.OutputReplica('[process_vote_msg] Formed QC from votes at round {}'.format(self._state.paceMaker.current_round))
            self.process_certificate(qc)
            self.process_next_round_event(None)
            self.OutputReplica('[process_vote_msg] Exit')
    _Replica_handler_1377._labels = None
    _Replica_handler_1377._notlabels = None

    def _Replica_handler_1484(self, M, source):
        self.OutputReplica('[process_timeout_msg] Entry Inside process_timeout_msg receive handler')
        if (not Util.verify_message_dup(M[1], self._state.replicaInfos[source].public_key)):
            self.OutputReplica('[process_timeout_msg] Exit Validation Failed')
            return
        else:
            self.OutputReplica('[process_timeout_msg] Validation Successful')
        M = M[0]
        if self._state.waiting:
            self._state.waiting = False
            self._state.timedOut = True
        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self._state.paceMaker.advance_round_tc(M.last_round_tc)
        tc = self._state.paceMaker.process_remote_timeout(M)
        if tc:
            self.OutputReplica('[process_timeout_msg] Processing TC  ')
            self._state.paceMaker.advance_round_tc(tc)
            self.process_next_round_event(tc)
        self.OutputReplica('[process_timeout_msg] Exit')
    _Replica_handler_1484._labels = None
    _Replica_handler_1484._notlabels = None

    def _Replica_handler_1607(self, source):
        self.OutputReplica('[client_end] Received message to close the replica')
    _Replica_handler_1607._labels = None
    _Replica_handler_1607._notlabels = None

    def _Replica_handler_1622(self, block_id, source):
        self.OutputReplica('[validate] Entry Received validate')
        block = self._state.blockTree._ledger.committed_block(block_id)
        self.send(('validation_block', block), to=source)
        self.OutputReplica('[validate] Exit')
    _Replica_handler_1622._labels = None
    _Replica_handler_1622._notlabels = None

    def _Replica_handler_1696(self, M, source):
        self.OutputReplica('[BlockSyncMessage] Entry received block id {} '.format(M[0].id))
        if (source == self._state.replicaID):
            self._state.pending_blocks[M[0].id] += 1
            self._state.blockTree.pending_block_tree.add(M[0].qc.vote_info.id, M[0])
            self._state.blockTree._ledger.speculate(M[0].qc.vote_info.id, M[0])
            if (len(self._state.pending_blocks[M[0].id]) == ((2 * self._state.fCount) + 1)):
                self._state.blockTree._ledger.commit(M[0].id)
                self._state.paceMaker.current_round = M[0].roundNo
                self.OutputReplica('[BlockSyncMessage] Broadcast SyncMsgRequest ')
                if (not (M[1] == M[0].id)):
                    for (_, replicaInfo) in self._state.replicaInfos.items():
                        self.send(('SyncMsgRequest', (self._state.blockTree._ledger.get_last_commited, self._state.replicaID)), to=replicaInfo.process)
        self.OutputReplica('[BlockSyncMessage] Exit pending vote {} for sync block {}'.format(len(self._state.pending_blocks[M[0].id]), M[0].id))
    _Replica_handler_1696._labels = None
    _Replica_handler_1696._notlabels = None

    def _Replica_handler_1870(self, M, source):
        self.OutputReplica('[SyncMsgRequest] Entry ')
        if (not (source == M[1])):
            next_block = self._state.blockTree._ledger.get_next_block(M[0])
            last_committed_block = self._state.blockTree._ledger.last_committed_block
            self.send(('BlockSyncMessage', (next_block, last_committed_block)), to=source)
        self.OutputReplica('[SyncMsgRequest] Exit')
    _Replica_handler_1870._labels = None
    _Replica_handler_1870._notlabels = None
