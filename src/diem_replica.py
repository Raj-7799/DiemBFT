# -*- generated by 1.0.14 -*-
import da
PatternExpr_274 = da.pat.TuplePattern([da.pat.ConstantPattern('Yo bro')])
PatternExpr_365 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('cmd')])
PatternExpr_372 = da.pat.FreePattern('source')
PatternExpr_395 = da.pat.TuplePattern([da.pat.ConstantPattern('process_proposal_msg'), da.pat.FreePattern('P')])
PatternExpr_402 = da.pat.FreePattern('source')
PatternExpr_552 = da.pat.TuplePattern([da.pat.ConstantPattern('process_vote_msg'), da.pat.FreePattern('M')])
PatternExpr_559 = da.pat.FreePattern('source')
PatternExpr_587 = da.pat.TuplePattern([da.pat.ConstantPattern('process_timeout_msg'), da.pat.FreePattern('M')])
PatternExpr_594 = da.pat.FreePattern('source')
PatternExpr_646 = da.pat.TuplePattern([da.pat.ConstantPattern('message'), da.pat.FreePattern('msg')])
PatternExpr_653 = da.pat.FreePattern('source')
_config_object = {}
import sys
from Messages.ProposalMsg import ProposalMsg
from client.client_info import ClientInfo
from .replica_info import ReplicaInfo
from client import client
from mempool import mempool

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_274, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_365, sources=[PatternExpr_372], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_364]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_395, sources=[PatternExpr_402], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_394]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_552, sources=[PatternExpr_559], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_551]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_587, sources=[PatternExpr_594], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_586]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_646, sources=[PatternExpr_653], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_645])])

    def setup(self, replicaID, replicaInfos, faulty_replica_count, replica_count, delta, privateKey, clientInfos, **rest_669):
        super().setup(replicaID=replicaID, replicaInfos=replicaInfos, faulty_replica_count=faulty_replica_count, replica_count=replica_count, delta=delta, privateKey=privateKey, clientInfos=clientInfos, **rest_669)
        self._state.replicaID = replicaID
        self._state.replicaInfos = replicaInfos
        self._state.faulty_replica_count = faulty_replica_count
        self._state.replica_count = replica_count
        self._state.delta = delta
        self._state.privateKey = privateKey
        self._state.clientInfos = clientInfos
        self._state.replicaID = self._state.replicaID
        self._state.replicaInfos = self._state.replicaInfos
        self._state.fCount = self._state.faulty_replica_count
        self._state.rCount = self._state.replica_count
        self._state.tDelta = self._state.delta
        self._state.privateKey = self._state.privateKey
        self._state.clientInfos = self._state.clientInfos
        self._state.memPool = mempool.MemPool()
        self._state.blockTree = None
        self._state.leaderElection = None
        self._state.paceMaker = None
        self._state.safety = None

    def run(self):
        self.output('Yo Starting replica with pID', self._state.replicaID)
        super()._label('_st_label_271', block=False)

        def ExistentialOpExpr_272():
            for (_, _, (_ConstantPattern287_,)) in self._ReplicaReceivedEvent_0:
                if (_ConstantPattern287_ == 'Yo bro'):
                    if True:
                        return True
            return False
        _st_label_271 = 0
        while (_st_label_271 == 0):
            _st_label_271 += 1
            if ExistentialOpExpr_272():
                _st_label_271 += 1
            else:
                super()._label('_st_label_271', block=True)
                _st_label_271 -= 1

    def process_certificate(self, qc):
        self._state.blockTree.process_qc(qc)
        self._state.leaderElection.update_leaders(qc)
        self._state.paceMaker.advance_round(qc.vote_info.round)

    def process_next_round_event(self, last_tc):
        if (self._state.replicaID == self._state.leaderElection.get_leader(self._state.paceMaker.current_round)):
            block = self._state.blockTree.generate_block(self._state.memPool.get_transactions(), self._state.paceMaker.current_round)
            proposal_msg = ProposalMsg(block, last_tc, self._state.blockTree.high_commit_qc)
            for replicaInfo in self._state.replicaInfos:
                self.send(('process_proposal_msg', proposal_msg), to=replicaInfo.process)

    def _Replica_handler_364(self, cmd, source):
        self.output('Inserting cmd {} into mempool of replica {}'.format(cmd, self._state.replicaID))
        self._state.memPool.insert_command(cmd, source)
        self.output(self._state.memPool)
    _Replica_handler_364._labels = None
    _Replica_handler_364._notlabels = None

    def _Replica_handler_394(self, P, source):
        if (P is None):
            self.output('Received a null proposal at replica {}'.format(self._state.replicaID))
            return
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self._state.paceMaker.advance_round_tc(P.last_round_tc)
        current_round = self._state.paceMaker.currentRound
        current_leader = self._state.leaderElection.get_leader(current_round)
        sourceReplica = self._state.replicaInfos[source]
        if ((not (P.block.round == current_round)) or (not (sourceReplica.replicaID == current_leader)) or (not (P.block.author == sourceReplica.replicaID))):
            return
        self._state.blockTree.execute_and_insert(P)
        vote_message = self._state.safety.make_vote(P.block, P.last_round_tc)
        if vote_message:
            nextLeaderID = self._state.leaderElection.get_leader((current_round + 1))
            nextLeaderInfo = None
            for (_, replicaInfo) in self._state.replicaInfos:
                if (replicaInfo.replicaID == nextLeaderID):
                    nextLeaderInfo = replicaInfo
                    break
            self.output('Sending vote message to {} from {}', nextLeaderInfo.replicaID, self._state.replicaID)
            self.send(('vote', vote_message), to=nextLeaderInfo.process)
    _Replica_handler_394._labels = None
    _Replica_handler_394._notlabels = None

    def _Replica_handler_551(self, M, source):
        qc = self._state.blockTree.process_vote(M)
        if qc:
            self.process_certificate(qc)
            self.process_next_round_event(None)
    _Replica_handler_551._labels = None
    _Replica_handler_551._notlabels = None

    def _Replica_handler_586(self, M, source):
        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self._state.paceMaker.advance_round_tc(M.last_round_tc)
        tc = self._state.paceMaker.process_remote_timeout(M)
        if tc:
            self._state.paceMaker.advance_round_qc(tc)
            self.process_next_round_event(tc)
    _Replica_handler_586._labels = None
    _Replica_handler_586._notlabels = None

    def _Replica_handler_645(self, msg, source):
        if (msg == 'Hello'):
            self.output('Message received is 1')
        elif (msg == '2'):
            self.output('Message received is 2')
        else:
            self.output('Message received is not one of us')
    _Replica_handler_645._labels = None
    _Replica_handler_645._notlabels = None
