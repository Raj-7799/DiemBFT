from collections import Counter
import os
from diembft_logger import get_logger
from collections import defaultdict
import client_request as cr
import Util

diem_logger = get_logger(os.path.basename(__file__))

class Client(process):
  def setup(clientID: int, requests: int, clientTimeout: int, replicaInfos, private_key:str, public_key, f: int, runner_process):
    self.pID                 = clientID
    self.nReq                = requests
    self.verified            = 1
    self.timeout             = clientTimeout
    self.replicaInfos        = replicaInfos
    self.private_key         = private_key
    self.public_key          = public_key
    self.f                   = f
    self.responses           = defaultdict(list)
    self.pendingVerification = {}
    self.transactionMap      = {}
    self.runner_process      = runner_process

  
  def run():
    output("Broadcasting messages to replicas")
    ## Adding two nodes to commit qc.vote_info.parent_id block 
    client_request = [ str(x) + '-' + str(self.pID) for x in range(1,self.nReq + 1)] + ["dummy1" + "-" + str(self.pID),"dummy2" + "-" + str(self.pID)]
    for  i in  client_request:
      client_request = cr.ClientRequest(i, self, self.private_key, self.public_key)
      pendingVerification[client_request] = True
      
      for _, replicaInfo in self.replicaInfos.items():
        send(("request", client_request), to=replicaInfo.process)

    await(self.nReq == 0)
    
    for block_id, info in self.transactionMap.items():
      replica_id = info["replicas"][0]
      block_id = info["block_id"]
      output("Checking validation for {} and {}".format(replica_id, block_id))
      send(("validate", block_id), to=get_replica_info(replica_id).process)

    await(self.verified == 0)
    output(self.transactionMap,"Exit client")

    send(("client_done",), to=self.runner_process)


  def get_replica_info(replicaID):
    for _, replicaInfo in self.replicaInfos.items():
      if replicaInfo.replicaID == replicaID:
          return replicaInfo
  
  def receive(msg=("validation_block", block), from_=source):
    if block is None:
      return
    
    if block.payload.signature == Util.sign_object(block.payload.payload, self.private_key, self.public_key):
      output("Verified signature for block with id {}".format(block.id))
      self.verified -= 1
    else:
      output("Unable to verify signature")
    
  
  def check_block_state(transaction):
    transaction_counts = defaultdict(int)
    for entry in self.responses[transaction]:
      transaction_counts[entry[0]]+=1
    
    for bk_id, count in transaction_counts.items():
      if count == self.f + 1:
        replicaIds=[]
        output("Received f + 1 = {} messages for transaction {} and block_id {}".format(self.f + 1, transaction, bk_id))
        for x in self.responses[transaction]:
          if x[0]==bk_id:
            replicaIds.append(x[1])
                    
        self.transactionMap[transaction] = {"block_id":bk_id,"replicas":replicaIds}

        self.nReq -= 1
        break

  def receive(msg=("transaction_committed", obj), from_=source):
    block_id, block, author = obj
    self.responses[block].append([block_id,author])
    check_block_state(block)
