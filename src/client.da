from collections import Counter
import os
from diembft_logger import get_logger
from collections import defaultdict
import client_request as cr

diem_logger = get_logger(os.path.basename(__file__))

class Client(process):
  def setup(clientID: int, requests: int, clientTimeout: int, replicaInfos, private_key:str, public_key, f: int, runner_process):
    self.pID                 = clientID
    self.nReq                = requests
    self.timeout             = clientTimeout
    self.replicaInfos        = replicaInfos
    self.private_key         = private_key
    self.public_key          = public_key
    self.f                   = f
    self.responses           = defaultdict(list)
    self.pendingVerification = {}
    self.transactionMap = {}
    self.runner_process = runner_process


  
  def run():
    output("Broadcasting messages to replicas")
    ## Adding two nodes to commit qc.vote_info.parent_id block 
    client_request = [ str(x) for x in range(1,self.nReq + 1)]+["dummy1","dummy2"]
    for  i in  client_request:
      client_request = cr.ClientRequest(i, self, self.private_key, self.public_key)
      pendingVerification[client_request] = True
      
      for _, replicaInfo in self.replicaInfos.items():
        send(("request", client_request), to=replicaInfo.process)
      
    await(self.nReq == 0)
    output(self.transactionMap,"Exit client")
    ## TODO need to verify 
    send(("client_done"), to=self.runner_process)


  def receive(msg=("Yo bro",), from_=source):    
    if source in self.replicaInfos:  
      replicaInfo = self.replicaInfos[source]
      output("Got message from replica ", replicaInfo.replicaID)
      self.nReq -= 1
    else:
      output("Received unknown message")
    
  
  def check_block_state(transaction):
    transaction_counts = defaultdict(int)
    for entry in self.responses[transaction]:
      transaction_counts[entry[0]]+=1
    
    for bk_id, count in transaction_counts.items():
      if count == self.f + 1:
        replicaIds=[]
        output("Received f + 1 = {} messages for transaction {} and block_id {}".format(self.f + 1, transaction, bk_id))
        for x in self.responses[transaction]:
          if x[0]==bk_id:
            replicaIds.append(x[1])
                    
        self.transactionMap[transaction] = {"block_id":bk_id,"replicas":replicaIds}

        self.nReq -= 1
        break

  def receive(msg=("transaction_committed", obj), from_=source):
    block_id, block, author = obj
    self.responses[block].append([block_id,author])
    check_block_state(block)
