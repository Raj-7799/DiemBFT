import BlockTree as bt

from client_info import ClientInfo
import mempool
from replica_info import ReplicaInfo
import Pacemaker as PM
import Safety as sf
import leader_election as le
import ProposalMsg as plm
import pickle
import sys
import os
from diembft_logger import get_logger

diem_logger = get_logger(os.path.basename(__file__))

class Replica(process):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]"):
        self.replicaID = replicaID
        self.replicaInfos = replicaInfos
        self.fCount = faulty_replica_count
        self.rCount = replica_count
        self.tDelta = delta
        self.privateKey = privateKey
        self.publicKey = get_replica_public_key(self.replicaID)
        self.clientInfos = clientInfos
        self.memPool = mempool.MemPool()

        self.blockTree = bt.BlockTree(self.fCount, self.replicaID, self.privateKey, get_replica_public_key(self.replicaID))
        self.safety = sf.Safety(blockTree, get_replica_public_keys(), self.replicaID)
        self.paceMaker = PM.Pacemaker(self.safety, self.blockTree, self.tDelta, self.fCount, pacemaker_broadcast_timeout, self.replicaID)
        self.leaderElection = le.LeaderElection(self.fCount, self.paceMaker, self.blockTree._ledger, get_replica_ids(), self.replicaID)

    def broadcast_helper(method, message):
        for _, replicaInfo in self.replicaInfos.items():
            send((method, message), to=replicaInfo.process)
    
    def get_replica_info(replicaID):
        for _, replicaInfo in self.replicaInfos.items():
            if replicaInfo.replicaID == replicaID:
                return replicaInfo
    
    def get_replica_ids():
        replicaIDs = []
        for _, replicaInfo in self.replicaInfos.items():
            replicaIDs.append(replicaInfo.replicaID)
        return replicaIDs

    def pacemaker_broadcast_timeout(tmo_message):
        diem_logger.debug("Pacemaker of {} broadcasting timeout.".format(self.replicaID))
        self.broadcast_helper("process_timeout_msg", tmo_message)

    def get_replica_public_key(replicaID):
        replicaInfo = get_replica_info(replicaID)
        return replicaInfo.public_key
    
    def get_replica_public_keys():
        keys = []
        for _, replicaInfo in self.replicaInfos.items():
            keys.append(replicaInfo.public_key)

        return keys

    def run():
        output("Starting replica with pID", self.replicaID)
        await(some(received(("Yo bro",))))


    def process_certificate(qc):
        diem_logger.debug("START: process_certificate {}".format(self.replicaID))
        self.blockTree.process_qc(qc)
        self.leaderElection.update_leaders(qc)
        self.paceMaker.advance_round_qc(qc)
        diem_logger.debug("END: process_certificate {}".format(self.replicaID))

    def process_next_round_event(last_tc):
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            transaction = memPool.get_transactions()
            while not transaction:
                transaction = memPool.get_transactions() 
            
            block = blockTree.generate_block(transaction, paceMaker.current_round)
            diem_logger.info("Generated block with block_id {} at replica {}".format(block.payload, self.replicaID))
            proposal_msg = plm.ProposalMsg(block, last_tc, blockTree.high_commit_qc, self.privateKey, self.publicKey)
            for _, replicaInfo in replicaInfos.items():
                send(("process_proposal_msg", proposal_msg), to=replicaInfo.process)

    def receive(msg=("request", cmd), from_=source):
        diem_logger.info("Inserting cmd {} into mempool of replica {}".format(cmd, self.replicaID))
        self.memPool.insert_command(cmd, source)
        self.paceMaker.start_timer(1)
        process_next_round_event(None)
    
    def receive(msg=("process_proposal_msg", P), from_=source):
        diem_logger.info("Received proposal at replica {} with Block payload is {}".format(self.replicaID, P.block.payload))

        if P is None:
            diem_logger.info("Received a null proposal at replica {}".format(self.replicaID))
            return
        
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self.paceMaker.advance_round_tc(P.last_round_tc)

        current_round = self.paceMaker.current_round
        current_leader = self.leaderElection.get_leader(current_round)

        sourceReplica = self.replicaInfos[source]
        diem_logger.info("Block author as {}".format(P.block.author))
        
        if P.block.roundNo != current_round or sourceReplica.replicaID != current_leader or P.block.author != sourceReplica.replicaID:
            diem_logger.info("Incosistency in round no or message source or block author for block {} at replica {}".format(P.block.payload, self.replicaID))
            return
        
        blockTree.execute_and_insert(P.block)
        vote_message = self.safety.make_vote(P.block, P.last_round_tc)
        if vote_message:
            nextLeaderID = self.leaderElection.get_leader(current_round + 1)
            diem_logger.info("Next leader for the round {} is at replica {}, processed at replica {}".format(current_round + 1, nextLeaderID, self.replicaID))
            nextLeaderInfo = None
            
            for _,replicaInfo in self.replicaInfos.items():
                if replicaInfo.replicaID == nextLeaderID:
                    nextLeaderInfo = replicaInfo
                    break
            
            diem_logger.info("Sending vote message to next leader : {} from {}".format(nextLeaderInfo.replicaID, self.replicaID))
            send(("process_vote_msg", vote_message), to=nextLeaderInfo.process)
        else:
            diem_logger.info("Unable to make vote for block {} at replica {}".format(P.block.payload, self.replicaID))


    def receive(msg=("process_vote_msg", M), from_=source):
        qc = self.blockTree.process_vote(M)

        if qc:
            self.process_certificate(qc)
            self.process_next_round_event(None)

    def receive(msg=("process_timeout_msg", M), from_=source):
        diem_logger.info("Received process_timeout_msg at replica {}".format(self.replicaID))

        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self.paceMaker.advance_round_tc(M.last_round_tc)

        tc = self.paceMaker.process_remote_timeout(M)
        if tc:
            # In paper Pacemaker.advance round(tc)
            # it should be Pacemaker.adbance_round_tc(tc)
            self.paceMaker.advance_round_tc(tc)
            self.process_next_round_event(tc)