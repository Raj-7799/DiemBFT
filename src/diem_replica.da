import BlockTree

from client_info import ClientInfo
import mempool
from replica_info import ReplicaInfo
import Pacemaker as PM

class Replica(process):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]"):
        self.replicaID = replicaID
        self.replicaInfos = replicaInfos
        self.fCount = faulty_replica_count
        self.rCount = replica_count
        self.tDelta = delta
        self.privateKey = privateKey
        self.clientInfos = clientInfos
        self.memPool = mempool.MemPool()

        self.leaderElection = None
        self.safety = None
        self.blockTree = BlockTree.BlockTree(self.fCount,self.replicaID, self.privateKey, get_replica_public_key(self.replicaID))
        self.paceMaker = PM.Pacemaker(self.safety, self.blockTree, self.tDelta, self.fCount, pacemaker_broadcast_timeout)
        #self.paceMaker.start_timer(0);

    def get_replica_info(replicaID):
        for _, replicaInfo in self.replicaInfos.items():
            if replicaInfo.replicaID == replicaID:
                return replicaInfo

    def pacemaker_broadcast_timeout(tmo_message):
        output("Pacemaker broadcasting timeout lol!")
        for _, replicaInfo in self.replicaInfos.items():
            send(("process_timeout_message", "tmo_message"), to=replicaInfo.process)

    def get_replica_public_key(replicaID):
        replicaInfo = get_replica_info(replicaID)
        return replicaInfo.public_key
    
    def run():
        output("Yo Starting replica with pID", self.replicaID)
        output("Yo Starting replica with pID")
        await(some(received(("Yo bro",))))


    def process_certificate(qc):
        self.blockTree.process_qc(qc)
        self.leaderElection.update_leaders(qc)
        self.paceMaker.advance_round(qc.vote_info.round)

    def process_next_round_event(last_tc):
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            block = blockTree.generate_block(memPool.get_transactions(), paceMaker.current_round)
            proposal_msg = ProposalMsg(block, last_tc, blockTree.high_commit_qc)

            for replicaInfo in replicaInfos:
                send(("process_proposal_msg", proposal_msg), to=replicaInfo.process)

    def receive(msg=("request", cmd), from_=source):
        output("Inserting cmd {} into mempool of replica {}".format(cmd, self.replicaID))
        self.memPool.insert_command(cmd, source)
        output(memPool)
    
    def receive(msg=("process_proposal_msg", P), from_=source):
        if P is None:
            output("Received a null proposal at replica {}".format(self.replicaID))
            return
        
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self.paceMaker.advance_round_tc(P.last_round_tc)
        

        current_round = self.paceMaker.currentRound
        current_leader = self.leaderElection.get_leader(current_round)

        sourceReplica = self.replicaInfos[source]
        
        if P.block.round != current_round or sourceReplica.replicaID != current_leader or P.block.author != sourceReplica.replicaID:
            return
        
        blockTree.execute_and_insert(P)

        vote_message = self.safety.make_vote(P.block, P.last_round_tc)

        if vote_message:
            nextLeaderID = self.leaderElection.get_leader(current_round + 1)
            nextLeaderInfo = None
            for _,replicaInfo in replicaInfos:
                if replicaInfo.replicaID == nextLeaderID:
                    nextLeaderInfo = replicaInfo
                    break
            
            output("Sending vote message to {} from {}", nextLeaderInfo.replicaID, self.replicaID)
            send(("vote", vote_message), to=nextLeaderInfo.process)


    def receive(msg=("process_vote_msg", M), from_=source):
        qc = self.blockTree.process_vote(M)

        if qc:
            self.process_certificate(qc)
            self.process_next_round_event(None)

    def receive(msg=("process_timeout_msg", M), from_=source):
        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self.paceMaker.advance_round_tc(M.last_round_tc)

        tc = self.paceMaker.process_remote_timeout(M)
        if tc:
            self.paceMaker.advance_round_qc(tc)
            self.process_next_round_event(tc)

    def receive(msg=("message", msg), from_=source):
        if msg == "Hello":
            output("Message received is 1")
        elif msg == "2":
            output("Message received is 2")
        else:
            output("Message received is not one of us")