import BlockTree as bt

from client_info import ClientInfo
import mempool
import Message
from replica_info import ReplicaInfo
import Pacemaker as PM
import PacemakerByz as pmbyz
import Safety as sf
import SafetyByz as sfbyz
import leader_election as le
import ProposalMsg as plm
import pickle
import sys
import os
import Util
from diembft_logger import get_logger
import time



class Replica(process):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]", specialArgs: dict):
        self.replicaID = replicaID
        self.replicaInfos = replicaInfos
        self.fCount = faulty_replica_count
        self.rCount = replica_count
        self.tDelta = delta
        self.privateKey = privateKey
        self.publicKey = get_replica_public_key(self.replicaID)
        self.clientInfos = clientInfos
        self.memPool = mempool.MemPool()
        self.firstRequestProcess = False
        self.waiting = False
        self.timedOut = False


        self.blockTree = bt.BlockTree(self.fCount, self.replicaID, self.privateKey, get_replica_public_key(self.replicaID), self.memPool, client_response_handler,send_sync_message,self.OutputLoggerBlockTree)
        self.safety = sf.Safety(blockTree, get_replica_public_keys(), self.replicaID,self.OutputLoggerSafety)
        self.paceMaker = PM.Pacemaker(self.safety, self.blockTree, self.tDelta, self.fCount, pacemaker_broadcast_timeout, self.replicaID,self.OutputLoggerPacemaker)
        self.leaderElection = le.LeaderElection(self.fCount, self.paceMaker, self.blockTree._ledger, get_replica_ids(), self.replicaID,self.OutputLeaderElection)


        self.pending_blocks=dict()
        self.candidate_block_to_commit = dict()
        self.diem_logger = get_logger(os.path.basename(__file__),self.replicaID)
        self.diem_logger.info("Hello")

    
 
    def OutputLoggerPacemaker(log):
        output("[Pacemaker][ReplicaID-{}][{}]".format(self.replicaID,log))

    def OutputLoggerSafety(log):
        output("[Safety][ReplicaID-{}][{}]".format(self.replicaID,log))

    def OutputLoggerBlockTree(log):
        output("[BlockTree][ReplicaID-{}][{}]".format(self.replicaID,log))

    def OutputLeaderElection(log):
        output("[LeaderElection][ReplicaID-{}][{}]".format(self.replicaID,log))




    def broadcast_helper(method, message):
        for _, replicaInfo in self.replicaInfos.items():
            send((method, message), to=replicaInfo.process)

    def client_response_handler(request):
        send(("transaction_committed", request), to=request[1].source)

    def get_replica_info(replicaID):
        for _, replicaInfo in self.replicaInfos.items():
            if replicaInfo.replicaID == replicaID:
                return replicaInfo
    
    def get_replica_ids():
        replicaIDs = []
        for _, replicaInfo in self.replicaInfos.items():
            replicaIDs.append(replicaInfo.replicaID)
        return replicaIDs

    def pacemaker_broadcast_timeout(tmo_message):
        self.diem_logger.debug("[replicaID {}] Pacemaker broadcasting timeout.".format(self.replicaID))
        SIGNED_MSG = Util.sign_object_dup(tmo_message, self.privateKey)
        #send(("process_proposal_msg", [tmo_message, SIGNED_MSG]), to=replicaInfo.process)
        self.broadcast_helper("process_timeout_msg", [tmo_message, SIGNED_MSG])

    def get_replica_public_key(replicaID):
        replicaInfo = get_replica_info(replicaID)
        return replicaInfo.public_key
    
    def get_replica_public_keys():
        keys = []
        for _, replicaInfo in self.replicaInfos.items():
            keys.append(replicaInfo.public_key)

        return keys

    def run():
        await(some(received(("client_end"))))


    def process_certificate(qc):
        self.diem_logger.info("[replicaID {}] Processing QC {} for vote_info {} at round {}".format(self.replicaID, qc, qc.vote_info.id, self.paceMaker.current_round))
        self.blockTree.process_qc(qc)
        self.leaderElection.update_leaders(qc)
        self.paceMaker.advance_round_qc(qc)

    def process_next_round_event(last_tc):
        # self.diem_logger.debug("[replicaID {}] New Round event {}".format(self.replicaID, self.replicaID == leaderElection.get_leader(paceMaker.current_round)))
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            transaction = memPool.get_transactions()

            if not transaction:
                self.waiting = True
                self.timedOut = False
                output("[replicaID {}] Waiting for transactions in mempool".format(self.replicaID))
                output("[replicaID {}] Mempoool state {}".format(self.replicaID, self.memPool.print()))
                --request
                await(self.waiting == False)
            
            if self.timedOut:
                output("[replicaID {}] Timed out while waiting for transaction".format(self.replicaID))
                return

            if transaction is None:
                self.waiting = False
                self.timedOut = False
                transaction = memPool.get_transactions()
                output("[replicaID {}] Transaction after waiting {}".format(self.replicaID, transaction))

            block = blockTree.generate_block(transaction, paceMaker.current_round)
            self.diem_logger.info("[replicaID {}] Generated block with block_id {} for transaction {} at round {}".format(self.replicaID, block.id, transaction, paceMaker.current_round))
            self.diem_logger.info("[replicaID {}] Mempool state {}".format(self.replicaID, self.memPool))
            proposal_msg = plm.ProposalMsg(block, last_tc, blockTree.high_commit_qc, self.privateKey, self.publicKey)
            self.diem_logger.info("[replicaID {}] Broadcasting proposal message for block with block_id {} at round {}".format(self.replicaID, block.id, paceMaker.current_round))
            for _, replicaInfo in self.replicaInfos.items():
                SIGNED_MSG = Util.sign_object_dup(proposal_msg, self.privateKey)
                send(("process_proposal_msg", [proposal_msg, SIGNED_MSG]), to=replicaInfo.process)

    def receive(msg=("request", cmd), from_=source):
        self.diem_logger.info("Received client request. Inserting cmd {} into mempool of replica".format(cmd))
        if not Util.verify_message_dup(cmd.signature, self.clientInfos[source].public_key):
            output("[replicaID {}] Received forged client signature".format(self.replicaID))
            return
        else:
            output("[replicaID {}] Client signature looks good".format(self.replicaID))
        
        output("[replicaID {}] Waiting state {}".format(self.replicaID, self.waiting))
        self.waiting = False

        self.memPool.insert_command(cmd, source)
        if not self.firstRequestProcess:
            if self.replicaID == 0:
                self.paceMaker.advance_round_qc(self.blockTree._high_qc)
        
            self.firstRequestProcess = True
            process_next_round_event(None)
        
    def receive(msg=("process_proposal_msg", P), from_=source):
        output('Inside process_proposal_msg receive handler')
        if not Util.verify_message_dup(P[1], self.replicaInfos[source].public_key):
           output("Validation Failed")
           return
        else:
            output("Validation Successful")
        P=P[0]
        output("type of process_proposal_msg = " + str(type(P.block)))
        self.diem_logger.info("[ Received proposal msg with Block ID : {} at round {}".format(P.block.id, self.paceMaker.current_round))

        if P is None:
            self.diem_logger.info("Received a null proposal".format(self.replicaID))
            return
        
        self.memPool.markState(P.block.payload)
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self.paceMaker.advance_round_tc(P.last_round_tc)

        current_round = self.paceMaker.current_round
        current_leader = self.leaderElection.get_leader(current_round)

        sourceReplica = self.replicaInfos[source]

        if P.block.roundNo != current_round or sourceReplica.replicaID != current_leader or P.block.author != sourceReplica.replicaID:

            self.diem_logger.info("[replicaID {}] Inconsistency {} {} {} {} {} {} {}".format(self.replicaID, P.block.id, P.block.roundNo, current_round, sourceReplica.replicaID, current_leader, P.block.author, sourceReplica.replicaID))
            self.diem_logger.info("[replicaID {}] Inconsistency in round no or message source or block author for block {}".format(self.replicaID, P.block.id))
            return
        
        blockTree.execute_and_insert(P.block,self.paceMaker.current_round)
        vote_message = self.safety.make_vote(P.block, P.last_round_tc)
        if vote_message:
            nextLeaderID = self.leaderElection.get_leader(current_round + 1)
            self.diem_logger.info("[replicaID {}] Next leader for the round {} is at replica {}".format(self.replicaID, current_round + 1, nextLeaderID))
            nextLeaderInfo = None
            
            for _,replicaInfo in self.replicaInfos.items():
                if replicaInfo.replicaID == nextLeaderID:
                    nextLeaderInfo = replicaInfo
                    break
            
            self.diem_logger.info("[replicaID {}] Sending vote message to next leader : {} for block ID {} at round {}".format(self.replicaID, nextLeaderInfo.replicaID, P.block.id, self.paceMaker.current_round))
            SIGNED_MSG = Util.sign_object_dup(vote_message, self.privateKey)
            send(("process_vote_msg", [vote_message, SIGNED_MSG]), to=nextLeaderInfo.process)
        else:
            self.diem_logger.info("[replicaID {}] Unable to make vote for block {}".format(self.replicaID, P.block.id))

    def receive(msg=("process_vote_msg", M), from_=source):
        output('Inside process_vote_msg receive handler')
        if not Util.verify_message_dup(M[1], self.replicaInfos[source].public_key):
           output("Validation Failed")
        else:
            output("Validation Successful")
        
        M=M[0]
        self.diem_logger.info("[replicaID {}] Received vote message from {} for block {} at round {}".format(self.replicaID, M.sender, M.vote_info.id, self.paceMaker.current_round))
        qc = self.blockTree.process_vote(M)

        if qc:
            self.diem_logger.info("[replicaID {}] Formed QC from votes at round {}".format(self.replicaID, self.paceMaker.current_round))
            self.process_certificate(qc)
            self.process_next_round_event(None)

    def receive(msg=("process_timeout_msg", M), from_=source):
        output('Inside process_timeout_msg receive handler')
        if not Util.verify_message_dup(M[1], self.replicaInfos[source].public_key):
           output("Validation Failed")
           return
        else:
            output("Validation Successful")
        
        M=M[0]
        self.diem_logger.info("[replicaID {}] Received process_timeout_msg at replica".format(self.replicaID))

        if self.waiting:
            self.waiting = False
            self.timedOut = True

        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self.paceMaker.advance_round_tc(M.last_round_tc)

        tc = self.paceMaker.process_remote_timeout(M)
        if tc:
            # In paper Pacemaker.advance round(tc)
            # it should be Pacemaker.adbance_round_tc(tc)
            self.paceMaker.advance_round_tc(tc)
            self.process_next_round_event(tc)
    
    def receive(msg=("client_end"), from_=source):
        output("Received message to close the replica")
    
    def receive(msg=("validate", block_id), from_=source):
         
        output("[replicaID {}] Received validate at replica".format(self.replicaID))
        block = self.blockTree._ledger.committed_block(block_id)
        send(("validation_block", block), to=source)

    

    def send_sync_message(sync_status_object):
        for _, replicaInfo in self.replicaInfos.items():
            send(("SyncMsgRequest",sync_status_object),to=replicaInfo.process)

    
    def receive(msg=("BlockSyncMessage",M), from_=source):

        if source==self.replicaID:
            self.pending_blocks[M[0].id]+=1
            self.candidate_block_to_commit[M[0].id]=M.next_block
            self.blockTree.pending_block_tree.add(M[0].qc.vote_info.id,M[0])

            if pending_blocks[M[0].id] == 2*self.fCount + 1:
                self.blockTree._ledger.commit(M[0].id)
                self.paceMaker.current_round=M[0].roundNo
                if M[1] != M[0].id:
                    for _, replicaInfo in self.replicaInfos.items():
                        send(("SyncMsgRequest",(self.blockTree._ledger.get_last_commited,self.replicaID)), to=replicaInfo.process)


    def receive(msg=("SyncMsgRequest",M), from_=source):

        if source != M[1]:
            next_block =  self.blockTree._ledger.get_next_block(M[0])
            last_committed_block=self.blockTree._ledger.last_committed_block
            send(("BlockSyncMessage",(next_block,last_committed_block)),to=source)



