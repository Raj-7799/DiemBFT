import sys
import ProposalMsg

from client_info import ClientInfo
from replica_info import ReplicaInfo
import mempool
#import Pacemaker as PM
from vote import VoteInfo as vi
import Util
import pickle
from VoteInfo import VoteInfo
from TimeoutInfo import TimeoutInfo
from Quorum import QC

from BlockTree import BlockTree as bt

from Quorum import QC as qc
from diembft_logger import get_logger

replica_logger = get_logger("diem_replica")

class Replica(process):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]"):
        self.replicaID = replicaID
        self.replicaInfos = replicaInfos
        self.fCount = faulty_replica_count
        self.rCount = replica_count
        self.tDelta = delta
        self.privateKey = privateKey
        self.clientInfos = clientInfos
        self.memPool = mempool.MemPool()

        genesis_qc ,genesis_block = self.create_genesis_object()
        self.blockTree = bt.BlockTree(genesis_qc,genesis_block,self.fCount,self.replicaID)

        self.leaderElection = None
        self.paceMaker = None  #Pacemaker()
        self.safety = None
        #self.replica_logger=diem_logger
        

    ## Creating genesis block for startup 
    def create_genesis_object(self):
        genesis_voteInfo = vi.VoteInfo(id=0,round_no=0,parent_id=0,parent_round=0,exec_state_id=0)
        ledger_commit_info = lci.LedgerCommitInfo(commit_state_id=0,vote_info_hash=genesis_voteInfo)  
        genesis_qc = qc.QC(vote_info=genesis_voteInfo,ledger_commit_info=ledger_commit_info)
        genesis =  blk.Block(0,0,"genesis",genesis_qc)
        return genesis_qc , genesis


    def get_replica_info(replicaID):
        for _, replicaInfo in self.replicaInfos.items():
            if replicaInfo.replicaID == replicaID:
                return replicaInfo
    

    def get_replica_public_key(replicaID):
        replicaInfo = get_replica_info(replicaID)
        return replicaInfo.public_key
    
    def run():
        replica_logger.debug("diem_replica: run {}".format(1))
        output("Yo Starting replica with pID", self.replicaID)
        output("Yo Starting replica with pID")
        await(some(received(("Yo bro",))))


    def process_certificate(qc):
        replica_logger.debug("diem_replica START: In process_certificate ")
        self.blockTree.process_qc(qc)
        self.leaderElection.update_leaders(qc)
        self.paceMaker.advance_round(qc.vote_info.round)
        replica_logger.debug("diem_replica END: In process_certificate ")

    def process_next_round_event(last_tc):
        replica_logger.debug("diem_replica START: process_next_round_event ")
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            block = blockTree.generate_block(memPool.get_transactions(), paceMaker.current_round)
            proposal_msg = ProposalMsg(block, last_tc, blockTree.high_commit_qc)

            for replicaInfo in replicaInfos:
                send(("process_proposal_msg", proposal_msg), to=replicaInfo.process)
        replica_logger.debug("diem_replica END: process_next_round_event ")

    def receive(msg=("request", cmd), from_=source):
        replica_logger.debug("diem_replica START: request ")
        output("Inserting cmd {} into mempool of replica {}".format(cmd, self.replicaID))
        self.memPool.insert_command(cmd, source)
        output(memPool)
        replica_logger.debug("diem_replica END: request ")
    
    def receive(msg=("process_proposal_msg", P), from_=source):
        replica_logger.debug("diem_replica START: process_proposal_msg ")
        if P is None:
            output("Received a null proposal at replica {}".format(self.replicaID))
            return
        
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        self.paceMaker.advance_round_tc(P.last_round_tc)
        

        current_round = self.paceMaker.currentRound
        current_leader = self.leaderElection.get_leader(current_round)

        sourceReplica = self.replicaInfos[source]
        
        if P.block.round != current_round or sourceReplica.replicaID != current_leader or P.block.author != sourceReplica.replicaID:
            return
        
        blockTree.execute_and_insert(P)

        vote_message = self.safety.make_vote(P.block, P.last_round_tc)

        if vote_message:
            nextLeaderID = self.leaderElection.get_leader(current_round + 1)
            nextLeaderInfo = None
            for _,replicaInfo in replicaInfos:
                if replicaInfo.replicaID == nextLeaderID:
                    nextLeaderInfo = replicaInfo
                    break
            
            output("Sending vote message to {} from {}", nextLeaderInfo.replicaID, self.replicaID)
            send(("vote", vote_message), to=nextLeaderInfo.process)
        replica_logger.debug("diem_replica END: process_proposal_msg ")


    def receive(msg=("process_vote_msg", M), from_=source):
        replica_logger.debug("diem_replica START: process_vote_msg ")
        qc = self.blockTree.process_vote(M)

        if qc:
            self.process_certificate(qc)
            self.process_next_round_event(None)
        replica_logger.debug("diem_replica EMD: process_vote_msg ")

    def receive(msg=("process_timeout_msg", M), from_=source):
        replica_logger.debug("diem_replica START: process_timeout_msg ")
        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self.paceMaker.advance_round_tc(M.last_round_tc)

        tc = self.paceMaker.process_remote_timeout(M)
        if tc:
            self.paceMaker.advance_round_qc(tc)
            self.process_next_round_event(tc)
        replica_logger.debug("diem_replica END: process_timeout_msg ")

    def receive(msg=("message", msg), from_=source):
        replica_logger.debug("diem_replica START: message ")
        if msg == "Hello":
            output("Message received is 1")
        elif msg == "2":
            output("Message received is 2")
        else:
            output("Message received is not one of us")
        replica_logger.debug("diem_replica END: message ")