import BlockTree as bt

from client_info import ClientInfo
import mempool
from replica_info import ReplicaInfo
import Pacemaker as PM
import Safety as sf
import leader_election as le
import ProposalMsg as plm
import pickle
import sys
import os
from diembft_logger import get_logger

diem_logger = get_logger(os.path.basename(__file__))

class Replica(process):
    def setup(replicaID: int, replicaInfos, faulty_replica_count: int, replica_count: int, delta: int, privateKey: str, clientInfos: "dict[int, ClientInfo]"):
        self.replicaID = replicaID
        self.replicaInfos = replicaInfos
        self.fCount = faulty_replica_count
        self.rCount = replica_count
        self.tDelta = delta
        self.privateKey = privateKey
        self.publicKey = get_replica_public_key(self.replicaID)
        self.clientInfos = clientInfos
        self.memPool = mempool.MemPool()

        self.blockTree = bt.BlockTree(self.fCount, self.replicaID, self.privateKey, get_replica_public_key(self.replicaID))
        self.safety = sf.Safety(blockTree, get_replica_public_keys(), self.replicaID)
        self.paceMaker = PM.Pacemaker(self.safety, self.blockTree, self.tDelta, self.fCount, pacemaker_broadcast_timeout, self.replicaID)
        self.leaderElection = le.LeaderElection(self.fCount, self.paceMaker, self.blockTree._ledger, get_replica_ids())

    def broadcast_helper(method, message):
        for _, replicaInfo in self.replicaInfos.items():
            print("Broadcaset_helper ",method)
            send((method, message), to=replicaInfo.process)
    
    def get_replica_info(replicaID):
        for _, replicaInfo in self.replicaInfos.items():
            if replicaInfo.replicaID == replicaID:
                return replicaInfo
    
    def get_replica_ids():
        replicaIDs = []
        for _, replicaInfo in self.replicaInfos.items():
            replicaIDs.append(replicaInfo.replicaID)
        return replicaIDs

    def pacemaker_broadcast_timeout(tmo_message):
        output("Pacemaker of {} broadcasting timeout!".format(self.replicaID))
        self.broadcast_helper("process_timeout_msg", tmo_message)

    def get_replica_public_key(replicaID):
        replicaInfo = get_replica_info(replicaID)
        return replicaInfo.public_key
    
    def get_replica_public_keys():
        keys = []
        for _, replicaInfo in self.replicaInfos.items():
            keys.append(replicaInfo.public_key)

        return keys

    def run():
        output("Yo Starting replica with pID", self.replicaID)
        output("Yo Starting replica with pID")
        await(some(received(("Yo bro",))))


    def process_certificate(qc):
        diem_logger.debug("START: process_certificate {}".format(self.replicaID))
        output("BlockTree processing qc {}".format(self.replicaID))
        self.blockTree.process_qc(qc)
        output("Leader Election updating leaders {}".format(self.replicaID))
        self.leaderElection.update_leaders(qc)
        output("PaceMaker advancing round qc {}".format(self.replicaID))
        self.paceMaker.advance_round_qc(qc)
        output("PaceMaker advancing round qc ends {}".format(self.replicaID))
        diem_logger.debug("END: process_certificate {}".format(self.replicaID))

    def process_next_round_event(last_tc):
        if self.replicaID == leaderElection.get_leader(paceMaker.current_round):
            block = blockTree.generate_block(memPool.get_transactions(), paceMaker.current_round)
            output("Creating proposal message")
            proposal_msg = plm.ProposalMsg(block, last_tc, blockTree.high_commit_qc, self.privateKey, self.publicKey)
            output("Sending proposal message")
            for _, replicaInfo in replicaInfos.items():
                #if self.replicaID == replicaInfo.replicaID:
                output("Size of propsal message {}".format(sys.getsizeof(proposal_msg)))
                send(("process_proposal_msg", proposal_msg), to=replicaInfo.process)

    def receive(msg=("request", cmd), from_=source):
        output("Inserting cmd {} into mempool of replica {}".format(cmd, self.replicaID))
        self.memPool.insert_command(cmd, source)
        process_next_round_event(None)
        output(memPool)
    
    def receive(msg=("process_proposal_msg", P), from_=source):
        
        output("Received proposal at replica {}".format(self.replicaID))
        output("Size of propsal message recv {}".format(sys.getsizeof(P)))
        if P is None:
            output("Received a null proposal at replica {}".format(self.replicaID))
            return
        
        output("Processing certificate")
        self.process_certificate(P.block.qc)
        self.process_certificate(P.high_commit_qc)
        output("Advancing round tc")
        self.paceMaker.advance_round_tc(P.last_round_tc)
        output("Advancing round tc ends")

        current_round = self.paceMaker.current_round
        current_leader = self.leaderElection.get_leader(current_round)

        sourceReplica = self.replicaInfos[source]
        
        if P.block.roundNo != current_round or sourceReplica.replicaID != current_leader or P.block.author != sourceReplica.replicaID:
            return
        output("Blocktree execute and insert start")
        blockTree.execute_and_insert(P.block)
        output("Blocktree execute and insert end")  
        output("Safey.make_vote start ")            
        vote_message = self.safety.make_vote(P.block, P.last_round_tc)
        output("Safey.make_vote end {} ".format(vote_message))  
        if vote_message:
            output("LeaderElection.get_leader start")
            nextLeaderID = self.leaderElection.get_leader(current_round + 1)
            output("LeaderElection.get_leader end leader : {}".format(nextLeaderID))
            nextLeaderInfo = None
            for _,replicaInfo in self.replicaInfos.items():
                if replicaInfo.replicaID == nextLeaderID:
                    nextLeaderInfo = replicaInfo
                    break
            
            output("Sending vote message to {} from {}", nextLeaderInfo.replicaID, self.replicaID)
            send(("vote", vote_message), to=nextLeaderInfo.process)
        output("process_proposal_msg END")


    def receive(msg=("process_vote_msg", M), from_=source):
        qc = self.blockTree.process_vote(M)

        if qc:
            self.process_certificate(qc)
            self.process_next_round_event(None)

    def receive(msg=("process_timeout_msg", M), from_=source):
        output("Received process_timeout_msg at replica {}".format(self.replicaID))

        self.process_certificate(M.tmo_info.high_qc)
        self.process_certificate(M.high_commit_qc)
        self.paceMaker.advance_round_tc(M.last_round_tc)

        tc = self.paceMaker.process_remote_timeout(M)
        if tc:
            #In paper Pacemaker.advance round(tc)
            # it should be Pacemaker.adbance_round_tc(tc)
            self.paceMaker.advance_round_tc(tc)
            self.process_next_round_event(tc)

    def receive(msg=("message", msg), from_=source):
        if msg == "Hello":
            output("Message received is 1")
        elif msg == "2":
            output("Message received is 2")
        else:
            output("Message received is not one of us")