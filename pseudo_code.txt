Validity check for Crytography

Function sign_object(msg,private_key,public_key):
    serialized_object = serialize the message
    hex_signed_object = sign serialized_object using private_key and hex-enccode the result
    encoded_verifying_key = hex-encode the verifying key [public_key ] 
    return [hex_signed_object,encoded_verifying_key]


Function verifying_message(signed_msg_object,verifying_key):
    decoded_signature = decode the signed_msg from hex to bytes
    if verify(decoded_signature,verifying_key)
        return True
    else:
        return false




Syncing up of replicas that got behind:
 
Pacemaker:

    Function sycn_lagging_node(block_round,qc,tc):
        if current_round <= max{highest_vote_round,qc.vote_info.round} then:
            // for a replica lagging behind its highest_vote_round will be less that the qc_round 
            // And qc_round will be greater than block round
            send sync event to every other replica
            SyncMsgRequest(Ledger.get_last_commited,sender=u)
    
    Function advance_round_qc(qc):
        if qc.vote_info.round < current_round then:
            return false
        last_round_tc <=None
        start_timer(qc.vote_info.round + 1 )

        if 

Main event Loop(M)

    if M is a SyncMsgRequest process_sync(M)
    if M is a BlockSyncMessage process_block(M)

Function process_sync(M):

    if u!=M.sender:
        next_block = Ledger.get_next_block(M.last_committed):
        last_committed_block = Ledger.get_last_commited()
        BlockSyncMessage(next_block,last_committed_block,sender=u)

    
Function process_sync(M):

    if u==M.sender:
        pending_blocks[M.next_block.id]++
        candidate_block_to_commit[M.next_block.id]=M.next_block
        Ledger.speculate(M.next_block.vote_info.id, M.next_block.id,M.next_block)
        if pending_blocks[M.next_block.id] == 2*f + 1
            // wait for a 2*f+1 blocks before we commit it to the ledger 
            Ledger.commit(M.next_block.id)
            SyncMsgRequest(Ledger.get_last_commited,sender=u)




// client requests: de-duplication; include appropriate requests in proposals

Client:

    MainLoop:Client_EventLoop
        loop: wait for next event M ; Main.start event processing(M)
        Procedure start_event_processing(M)
            if M is response then process_result(M)
            if M is timeout then on_timeout(M)

    Function sendMessage(message):
        send request for message 
        start_timer()

    Function on_timeout(M):
        sendMessage(M.message)

    start_timer():
        while(current_time < max_timeout):
            current_time = get_time_elapsed(start_time)
            process_result()
    
    Function process_result(M):

        if validate_response_signature(M): // use cryto verify to validate the message
            if process_command[cmd.id][response.id] == f+1:
                transaction_id = response.id
        

MemPool:

    insert_command(command):
        if command not in MemPool:
            insert command in MemPool


    